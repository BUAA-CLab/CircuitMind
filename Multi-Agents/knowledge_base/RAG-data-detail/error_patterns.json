[
  {
    "id": 0,
    "error_type": "Syntax Error",
    "error_level": "synthesis_error",
    "error_pattern": "Gates do not have port names",
    "error_message": "Error: Gates do not have port names.",
    "problem_description": "Incorrect syntax for gate instantiation. Primitive gate instantiations in Verilog do not support named port connections.",
    "root_cause": "Using named port connections (e.g., `.Y(out)`) when instantiating primitive gates like `and`, `or`, `not`, `buf`, `nand`, `nor`, `xor`, `xnor`.",
    "solution_pattern": "Use ordered port connections where the signal order matches the gate's input/output order. Refer to the Verilog language specification for correct syntax.",
    "code_before": "module second_tick (\n    input wire a,\n    input wire b,\n    output wire out\n);\n\n    wire b_not;\n\n    not not_b (\n        .Y(b_not),\n        .A(b)\n    );\n\n    and and_ab_not (\n        .Y(out),\n        .A(a),\n        .B(b_not)\n    );\n\nendmodule",
    "code_after": "module second_tick (\n    input wire a,\n    input wire b,\n    output wire out\n);\n\n    wire b_not;\n\n    not not_b (\n        b_not,\n        b\n    );\n\n    and and_ab_not (\n        out,\n        a,\n        b_not\n    );\n\nendmodule",
    "design_context": ["synthesis", "gate-level design"],
    "common_modules": ["primitive gates"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["verilog", "synthesis error", "gate instantiation", "primitive gate", "port names", "syntax error"]
  },
  {
    "id": 1,
    "error_type": "Syntax Error",
    "error_level": "synthesis_error",
    "error_pattern": "Syntax error in instance port expression(s)",
    "error_message": "Error: Invalid syntax for identifiers - identifiers in Verilog cannot contain spaces.",
    "problem_description": "Invalid syntax for identifiers (module instance names, wire names). Identifiers in Verilog cannot contain spaces.",
    "root_cause": "Including spaces within module instance names (e.g., `g_ab_ncn d`) or wire names (e.g., `w_ab_ncn d`).",
    "solution_pattern": "Remove all spaces from module instance names and wire names. Use underscores or camelCase for valid identifier naming conventions.",
    "code_before": "module counting_signals (\n    input wire a,\n    input wire b,\n    input wire c,\n    input wire d,\n    output [2:0] count\n);\n    wire w_ab_ncn d;\n    not g_na (na, a);\n    not g_nb (nb, b);\n    not g_nc (nc, c);\n    not g_nd (nd, d);\n    and g_ab_ncn d (w_ab_ncn d, a, b, nc, nd);\nendmodule",
    "code_after": "module counting_signals (\n    input wire a,\n    input wire b,\n    input wire c,\n    input wire d,\n    output [2:0] count\n);\n    wire w_ab_ncn_d;\n    not g_na (na, a);\n    not g_nb (nb, b);\n    not g_nc (nc, c);\n    not g_nd (nd, d);\n    and g_ab_ncn_d (w_ab_ncn_d, a, b, nc, nd);\nendmodule",
    "design_context": ["synthesis", "structural design"],
    "common_modules": ["logic gates"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["verilog", "synthesis error", "identifier", "naming convention", "syntax error", "instance name", "wire name", "spaces in identifier"]
  },
  {
    "id": 2,
    "error_type": "Syntax Error",
    "error_level": "synthesis_error",
    "error_pattern": "Syntax error",
    "error_message": "Error: Top-level declarations are not allowed outside of module, interface, or program blocks.",
    "problem_description": "Top-level declarations are not allowed outside of module, interface, or program blocks.",
    "root_cause": "Declaring signals (wires, regs, etc.) or instantiating modules outside of a defined module, interface, or program.",
    "solution_pattern": "Ensure all declarations and instantiations are within a `module`, `interface`, or `program` block.",
    "code_before": "wire w_xor1, w_xor2;\nxor g_xor1 (w_xor1, a, b);\nxor g_xor2 (w_xor2, c, d);\nxor g_count0 (count[0], w_xor1, w_xor2);",
    "code_after": "module counting_signals (\n    input wire a,\n    input wire b,\n    input wire c,\n    input wire d,\n    output reg [2:0] count\n);\n  wire w_xor1, w_xor2;\n  xor g_xor1 (w_xor1, a, b);\n  xor g_xor2 (w_xor2, c, d);\n  xor g_count0 (count[0], w_xor1, w_xor2);\nendmodule",
    "design_context": ["synthesis", "module definition"],
    "common_modules": ["top-level module"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["verilog", "synthesis error", "syntax error", "module", "interface", "program", "top-level declaration", "scope"]
  },
  {
    "id": 3,
    "error_type": "Syntax Error",
    "error_level": "synthesis_error",
    "error_pattern": "Module definition cannot nest into module",
    "error_message": "Error: Module definitions cannot be nested within other modules in Verilog.",
    "problem_description": "Module definitions cannot be nested within other modules in Verilog.",
    "root_cause": "Defining a module inside another module's definition.",
    "solution_pattern": "Move the nested module definition outside of the parent module's `endmodule` statement.",
    "code_before": "module adder_8bit (\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    input carry_in,\n    output [7:0] sum,\n    output carry_out\n);\n    wire [7:0] internal_sum;\n    wire [7:0] internal_carry;\n\n    module full_adder (input a, input b, input cin, output s, output cout);\n        wire xor_ab, and_ab, and_cin_xor_ab;\n        xor g1 (xor_ab, a, b);\n        and g2 (and_ab, a, b);\n        and g3 (and_cin_xor_ab, cin, xor_ab);\n        xor g4 (s, xor_ab, cin);\n        or  g5 (cout, and_ab, and_cin_xor_ab);\n    endmodule\n\n    full_adder fa0 (\n        .a(a[0]),\n        .b(b[0]),\n        .cin(carry_in),\n        .s(internal_sum[0]),\n        .cout(internal_carry[0])\n    );\nendmodule",
    "code_after": "module full_adder (input a, input b, input cin, output s, output cout);\n    wire xor_ab, and_ab, and_cin_xor_ab;\n    xor g1 (xor_ab, a, b);\n    and g2 (and_ab, a, b);\n    and g3 (and_cin_xor_ab, cin, xor_ab);\n    xor g4 (s, xor_ab, cin);\n    or  g5 (cout, and_ab, and_cin_xor_ab);\nendmodule\n\nmodule adder_8bit (\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    input carry_in,\n    output [7:0] sum,\n    output carry_out\n);\n    wire [7:0] internal_sum;\n    wire [7:0] internal_carry;\n\n    full_adder fa0 (\n        .a(a[0]),\n        .b(b[0]),\n        .cin(carry_in),\n        .s(internal_sum[0]),\n        .cout(internal_carry[0])\n    );\nendmodule",
    "design_context": ["synthesis", "module hierarchy"],
    "common_modules": ["structural modules"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["verilog", "synthesis error", "nested module", "module definition", "syntax error", "module hierarchy"]
  },
  {
    "id": 4,
    "error_type": "Declaration Error",
    "error_level": "synthesis_error",
    "error_pattern": "'(.+)' has already been declared in this scope",
    "error_message": "Error: Identifier (wire, reg, etc.) has already been declared within the current scope.",
    "problem_description": "Identifier (wire, reg, etc.) has already been declared within the current scope.",
    "root_cause": "Declaring the same wire or register name multiple times within the same module or block.",
    "solution_pattern": "Rename one of the conflicting identifiers to a unique name within the current scope.",
    "code_before": "module arithmetic_engine (\n    input [7:0] A,\n    input [7:0] B,\n    input [2:0] opcode,\n    output [7:0] result\n);\n    wire fa_carry_out_0, fa_carry_out_1, fa_carry_out_2, fa_carry_out_3;\n    wire fa_carry_out_4, fa_carry_out_5, fa_carry_out_6;\n    wire [7:0] b_inverted;\n    genvar j;\n    generate\n        for (j = 0; j < 8; j = j + 1) begin: invert_b\n            not inv_b (b_inverted[j], B[j]);\n        end\n    endgenerate\n    wire sub_carry_out_0, sub_carry_out_1, sub_carry_out_2, sub_carry_out_3;\n    wire sub_carry_out_4, sub_carry_out_5, sub_carry_out_6;\nendmodule",
    "code_after": "module arithmetic_engine (\n    input [7:0] A,\n    input [7:0] B,\n    input [2:0] opcode,\n    output [7:0] result\n);\n    wire fa_carry_out_0, fa_carry_out_1, fa_carry_out_2, fa_carry_out_3;\n    wire fa_carry_out_4, fa_carry_out_5, fa_carry_out_6;\n    wire [7:0] b_inverted;\n    genvar j;\n    generate\n        for (j = 0; j < 8; j = j + 1) begin: invert_b\n            not inv_b (b_inverted[j], B[j]);\n        end\n    endgenerate\n    wire sub_carry_out_0, sub_carry_out_1, sub_carry_out_2, sub_carry_out_3;\n    wire sub_carry_out_4, sub_carry_out_5, sub_carry_out_6;\nendmodule",
    "design_context": ["synthesis", "signal declaration"],
    "common_modules": ["arithmetic units"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["verilog", "synthesis error", "declaration error", "redeclared identifier", "wire", "scope"]
  },
  {
    "id": 5,
    "error_type": "Declaration Error",
    "error_level": "synthesis_error",
    "error_pattern": "genvar is missing for generate \"(.+)\" variable '(.+)'",
    "error_message": "Error: `genvar` declaration is missing for a variable used in a `generate` loop.",
    "problem_description": "`genvar` declaration is missing for a variable used in a `generate` loop.",
    "root_cause": "Using a variable as a loop index in a `generate` statement without declaring it as `genvar`.",
    "solution_pattern": "Declare the loop variable within the `generate` block as type `genvar` before the `for` loop.",
    "code_before": "module arithmetic_engine (\n    input [7:0] A,\n    input [7:0] B,\n    input [2:0] opcode,\n    output [7:0] result\n);\n    wire c_in_sub;\n    wire [7:0] carry_sub;\n    wire [7:0] b_inv;\n    assign c_in_sub = 1'b1;\n    generate\n        for (k = 0; k < 8; k = k + 1) begin : inv_b_loop\n            not g_not_b (b_inv[k], B[k]);\n        end\n    endgenerate\nendmodule",
    "code_after": "module arithmetic_engine (\n    input [7:0] A,\n    input [7:0] B,\n    input [2:0] opcode,\n    output [7:0] result\n);\n    wire c_in_sub;\n    wire [7:0] carry_sub;\n    wire [7:0] b_inv;\n    assign c_in_sub = 1'b1;\n    genvar k;\n    generate\n        for (k = 0; k < 8; k = k + 1) begin : inv_b_loop\n            not g_not_b (b_inv[k], B[k]);\n        end\n    endgenerate\nendmodule",
    "design_context": ["synthesis", "generate blocks"],
    "common_modules": ["arithmetic units"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["verilog", "synthesis error", "declaration error", "genvar", "generate loop"]
  },
  {
    "id": 6,
    "error_type": "Range Error",
    "error_level": "synthesis_error",
    "error_pattern": "Index (.+) is out of range",
    "error_message": "Error: Array index is out of the declared bounds for the array.",
    "problem_description": "Array index is out of the declared bounds for the array.",
    "root_cause": "Accessing an element of an array (wire, reg, memory) using an index that is greater than or equal to the array's size.",
    "solution_pattern": "Increase the array size to accommodate the final carry-out or adjust the loop condition to stay within bounds.",
    "code_before": "module arithmetic_engine (\n    input [7:0] A,\n    input [7:0] B,\n    input [2:0] opcode,\n    output [7:0] result\n);\n    wire [7:0] add_carry;\n    wire add_carry_in;\n    assign add_carry[0] = add_carry_in;\n    genvar j;\n    generate\n        for (j = 0; j < 8; j = j + 1) begin : adder_bits\n            xor add_sum_xor1 (add_out[j], A[j], B[j]);\n            xor add_sum_xor2 (w_add_sum, add_sum_xor1, add_carry[j]);\n            and add_carry_and1 (w_add_carry1, A[j], B[j]);\n            and add_carry_and2 (w_add_carry2, add_carry[j], add_sum_xor1);\n            or  add_carry_or  (add_carry[j+1], w_add_carry1, w_add_carry2);\n            assign add_out[j] = w_add_sum;\n        end\n    endgenerate\nendmodule",
    "code_after": "module arithmetic_engine (\n    input [7:0] A,\n    input [7:0] B,\n    input [2:0] opcode,\n    output [7:0] result\n);\n    wire [8:0] add_carry;\n    wire add_carry_in;\n    assign add_carry[0] = add_carry_in;\n    genvar j;\n    generate\n        for (j = 0; j < 8; j = j + 1) begin : adder_bits\n            xor add_sum_xor1 (add_out[j], A[j], B[j]);\n            xor add_sum_xor2 (w_add_sum, add_sum_xor1, add_carry[j]);\n            and add_carry_and1 (w_add_carry1, A[j], B[j]);\n            and add_carry_and2 (w_add_carry2, add_carry[j], add_sum_xor1);\n            or  add_carry_or  (add_carry[j+1], w_add_carry1, w_add_carry2);\n            assign add_out[j] = w_add_sum;\n        end\n    endgenerate\nendmodule",
    "design_context": ["synthesis", "array handling"],
    "common_modules": ["arithmetic units"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["verilog", "synthesis error", "range error", "array index", "out of bounds"]
  },
  {
    "id": 7,
    "error_type": "Binding Error",
    "error_level": "synthesis_error",
    "error_pattern": "Unable to bind wire/reg/memory `(.+)' in `(.+)'",
    "error_message": "Error: Unable to bind a wire, register, or memory identifier within a `generate` block.",
    "problem_description": "Unable to bind a wire, register, or memory identifier within a `generate` block, often due to incorrect scope or typo in the identifier name.",
    "root_cause": "Using a loop variable from a different `generate` block as an index or signal name within the current `generate` block.",
    "solution_pattern": "Verify that the loop variable used as an index or signal name corresponds to the current `generate` block.",
    "code_before": "module arithmetic_engine (\n    input [7:0] A,\n    input [7:0] B,\n    input [2:0] opcode,\n    output [7:0] result\n);\n    genvar i_or;\n    generate\n        for (i_or = 0; i_or < 8; i_or = i_or + 1) begin : or_gates\n            or g_or (w_or_result[i_or], A[i_or], B[i_or]);\n        end\n    endgenerate\n    genvar i_nor;\n    generate\n        for (i_nor = 0; i_nor < 8; i_nor = i_nor + 1) begin : nor_gates\n            nor g_nor (w_nor_result[i_nor], A[i_nor], B[i_or]);\n        end\n    endgenerate\nendmodule",
    "code_after": "module arithmetic_engine (\n    input [7:0] A,\n    input [7:0] B,\n    input [2:0] opcode,\n    output [7:0] result\n);\n    genvar i_or;\n    generate\n        for (i_or = 0; i_or < 8; i_or = i_or + 1) begin : or_gates\n            or g_or (w_or_result[i_or], A[i_or], B[i_or]);\n        end\n    endgenerate\n    genvar i_nor;\n    generate\n        for (i_nor = 0; i_nor < 8; i_nor = i_nor + 1) begin : nor_gates\n            nor g_nor (w_nor_result[i_nor], A[i_nor], B[i_nor]);\n        end\n    endgenerate\nendmodule",
    "design_context": ["synthesis", "generate blocks"],
    "common_modules": ["logic units"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["verilog", "synthesis error", "binding error", "generate block", "scope", "identifier", "loop variable"]
  },
  {
    "id": 8,
    "error_type": "Behavioral Construct in Structural Design",
    "error_level": "design_error",
    "error_pattern": "Behavioral construct in structural design",
    "error_message": "Error: Use of `always` block which is a behavioral-level construct in a strictly structural Verilog design.",
    "problem_description": "Use of `always` block which is a behavioral-level construct in a strictly structural Verilog design. Structural design should only include gate-level primitives and module instantiations.",
    "root_cause": "Incorrect understanding of structural Verilog or LLM not fully adhering to structural design constraints.",
    "solution_pattern": "Implement the design using only basic logic gates and module instantiations without behavioral constructs like `always`.",
    "code_before": "module elegant_storage (\n    input clk,\n    input rst,\n    input write_enable,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            data_out <= 8'b0;\n        end else begin\n            data_out <= current_data;\n        end\n    end\nendmodule",
    "code_after": "module elegant_storage (\n    input clk,\n    input rst,\n    input write_enable,\n    input [7:0] data_in,\n    output [7:0] data_out\n);\n    wire [7:0] dff_outputs;\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : storage_ff\n            wire dff_input;\n            and_gate enable_and_data (\n                .a(write_enable),\n                .b(data_in[i]),\n                .y(dff_input)\n            );\n            d_flip_flop data_ff (\n                .clk(clk),\n                .rst(rst),\n                .d(dff_input),\n                .q(dff_outputs[i])\n            );\n            d_flip_flop output_ff (\n              .clk(clk),\n              .rst(rst),\n              .d(dff_outputs[i]),\n              .q(data_out[i])\n            );\n        end\n    endgenerate\nendmodule",
    "design_context": ["design", "structural Verilog"],
    "common_modules": ["flip-flops", "logic gates"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["structural Verilog", "always block", "behavioral construct", "gate-level", "instantiation"]
  },
  {
    "id": 9,
    "error_type": "Incorrect Signal Type Assignment",
    "error_level": "compilation_error",
    "error_pattern": "reg (.+); cannot be driven by primitives or continuous assignment",
    "error_message": "Error: A `reg` type signal is being driven by a continuous assignment statement or a primitive.",
    "problem_description": "A `reg` type signal is being driven by a continuous assignment statement or a primitive, which is not allowed in Verilog.",
    "root_cause": "Using an `assign` statement to drive a `reg` type signal.",
    "solution_pattern": "Change the signal type from `reg` to `wire` if it is intended to be driven continuously.",
    "code_before": "module elegant_storage (\n    output reg [7:0] data_out\n);\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : bit_storage\n            and_gate and_inst (\n                .a(write_enable),\n                .b(data_in[i]),\n                .y(next_data_out[i])\n            );\n        end\n    endgenerate\n    always @(posedge clk) begin\n        data_out <= current_data;\n    end\nendmodule",
    "code_after": "module elegant_storage (\n    output [7:0] data_out\n);\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : dff_loop\n            d_flip_flop dff (\n                .clk(clk),\n                .rst(rst),\n                .d(next_data_out[i]),\n                .q(data_out[i])\n            );\n        end\n    endgenerate\nendmodule",
    "design_context": ["compilation", "signal assignment"],
    "common_modules": ["flip-flops", "logic gates"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["verilog", "compilation error", "reg", "wire", "continuous assignment", "procedural assignment"]
  },
  {
    "id": 10,
    "error_type": "Output Port Assignment Error",
    "error_level": "compilation_error",
    "error_pattern": "Output port expression must support continuous assignment",
    "error_message": "Error: An output port is being assigned in a way that is not allowed or not compatible with its type.",
    "problem_description": "An output port is being assigned in a way that is not allowed or not compatible with its type.",
    "root_cause": "Declaring an output port as `reg` but not assigning it within an `always` block.",
    "solution_pattern": "Declare output ports as `wire` if they are driven by combinational logic or directly by module outputs.",
    "code_before": "module elegant_storage (\n    output reg [7:0] data_out\n);\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : bit_storage\n            and_gate and_inst (\n                .a(write_enable),\n                .b(data_in[i]),\n                .y(next_data_out[i])\n            );\n            d_flip_flop dff_inst (\n                .clk(clk),\n                .rst(rst),\n                .d(next_data_out[i]),\n                .q(current_data[i]),\n                .q_not()\n            );\n        end\n    endgenerate\n    always @(posedge clk) begin\n      data_out <= current_data;\n    end\nendmodule",
    "code_after": "module elegant_storage (\n    output [7:0] data_out\n);\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : dff_loop\n            d_flip_flop dff (\n                .clk(clk),\n                .rst(rst),\n                .d(next_data_out[i]),\n                .q(data_out[i])\n            );\n        end\n    endgenerate\nendmodule",
    "design_context": ["compilation", "port assignment"],
    "common_modules": ["flip-flops", "logic gates"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["verilog", "compilation error", "output port", "reg", "wire", "assignment"]
  },
  {
    "id": 11,
    "error_type": "Undeclared Identifier",
    "error_level": "synthesis_error",
    "error_pattern": "Identifier '(.+)' is not declared",
    "error_message": "Error: Using a signal or variable that has not been declared.",
    "problem_description": "Using a signal or variable that has not been declared.",
    "root_cause": "Forgetting to declare a wire, reg, or input/output port.",
    "solution_pattern": "Ensure that all signals and variables are declared with the correct type (wire, reg, input, output).",
    "code_before": "module my_circuit (\n    input a,\n    input b,\n    output y\n);\n    and g1 (y, a, c);\nendmodule",
    "code_after": "module my_circuit (\n    input a,\n    input b,\n    output y\n);\n    wire c;\n    and g1 (y, a, c);\nendmodule",
    "design_context": ["synthesis", "signal declaration"],
    "common_modules": ["combinational logic"],
    "severity": "critical",
    "frequency": "common",
    "keywords": ["verilog", "synthesis error", "undeclared identifier", "missing declaration", "variable not defined"]
  },
  {
    "id": 12,
    "error_type": "Incorrect Testbench Stimulus",
    "error_level": "testbench_error",
    "error_pattern": "Simulation mismatch at time (.+)",
    "error_message": "Error: Testbench does not provide the correct input signals or timing to properly test the design.",
    "problem_description": "Testbench does not provide the correct input signals or timing to properly test the design.",
    "root_cause": "Incorrect sequence or values of input stimuli or insufficient time delay for signals to propagate.",
    "solution_pattern": "Increase delays (`#`) to allow for signal propagation and ensure input signals are driven correctly.",
    "code_before": "module testbench;\n    reg clk, rst, d;\n    wire q;\n    dff dut (.*);\n    initial begin\n        clk = 0;\n        rst = 1;\n        d = 0;\n        #10 rst = 0;\n        d = 1;\n        #5\n        $finish;\n    end\n    always #5 clk = ~clk;\nendmodule",
    "code_after": "module testbench;\n    reg clk, rst, d;\n    wire q;\n    dff dut (.*);\n    initial begin\n        clk = 0;\n        rst = 1;\n        d = 0;\n        #10 rst = 0;\n        #10 d = 1;\n        #10 $finish;\n    end\n    always #5 clk = ~clk;\nendmodule",
    "design_context": ["testbench", "simulation"],
    "common_modules": ["testbench", "DUT"],
    "severity": "major",
    "frequency": "common",
    "keywords": ["verilog", "testbench error", "stimulus", "timing", "delay", "simulation mismatch"]
  },
  {
    "id": 13,
    "error_type": "Incorrect Signal Type Assignment",
    "error_level": "compilation_error",
    "error_pattern": "reg (.+); cannot be driven by primitives or continuous assignment",
    "error_message": "Error: A `reg` type signal cannot be driven by a continuous assignment (`assign`) statement or primitives.",
    "problem_description": "A `reg` type signal cannot be driven by a continuous assignment (`assign`) statement or primitives.",
    "root_cause": "Using an `assign` statement to assign a value to a `reg` type signal.",
    "solution_pattern": "Change the `reg` type signal to `wire` if continuous assignment is needed.",
    "code_before": "module example (\n    input [3:0] a, b,\n    input cin,\n    output reg [3:0] sum,\n    output reg cout\n);\n    wire c0, c1, c2, c3;\n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c0));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(c0), .sum(sum[1]), .cout(c1));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(c1), .sum(sum[2]), .cout(c2));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(c2), .sum(sum[3]), .cout(c3));\n    assign cout = c0 | c1 | c2 | c3;\nendmodule",
    "code_after": "module example (\n    input [3:0] a, b,\n    input cin,\n    output wire [3:0] sum,\n    output wire cout\n);\n    wire c0, c1, c2, c3;\n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c0));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(c0), .sum(sum[1]), .cout(c1));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(c1), .sum(sum[2]), .cout(c2));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(c2), .sum(sum[3]), .cout(c3));\n    assign cout = c0 | c1 | c2 | c3;\nendmodule",
    "design_context": ["compilation", "signal assignment"],
    "common_modules": ["full adder"],
    "severity": "major",
    "frequency": "common",
    "keywords": ["verilog", "compilation error", "reg", "assign", "continuous assignment", "primitives"]
  },
  {
    "id": 14,
    "error_type": "Incorrect Output Port Type",
    "error_level": "compilation_error",
    "error_pattern": "Output port expression must support continuous assignment",
    "error_message": "Error: An output port of type `reg` cannot be directly assigned using a continuous assignment (`assign`).",
    "problem_description": "An output port of type `reg` cannot be directly assigned using a continuous assignment (`assign`).",
    "root_cause": "Declaring an output port as `reg` and attempting to assign it a value using an `assign` statement.",
    "solution_pattern": "Change the `reg` type output port to `wire`.",
    "code_before": "module example (\n    input [3:0] a, b,\n    input cin,\n    output reg [3:0] sum,\n    output reg cout\n);\n    wire c0, c1, c2, c3;\n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c0));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(c0), .sum(sum[1]), .cout(c1));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(c1), .sum(sum[2]), .cout(c2));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(c2), .sum(sum[3]), .cout(c3));\n    assign cout = c0 | c1 | c2 | c3;\nendmodule",
    "code_after": "module example (\n    input [3:0] a, b,\n    input cin,\n    output wire [3:0] sum,\n    output wire cout\n);\n    wire c0, c1, c2, c3;\n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c0));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(c0), .sum(sum[1]), .cout(c1));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(c1), .sum(sum[2]), .cout(c2));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(c2), .sum(sum[3]), .cout(c3));\n    assign cout = c0 | c1 | c2 | c3;\nendmodule",
    "design_context": ["compilation", "port assignment"],
    "common_modules": ["full adder"],
    "severity": "major",
    "frequency": "common",
    "keywords": ["verilog", "compilation error", "output port", "reg", "wire", "assign", "continuous assignment"]
  },
  {
    "id": 15,
    "error_type": "Incorrect Module Item",
    "error_level": "compilation_error",
    "error_pattern": "Invalid module item",
    "error_message": "Error: Using delay statements with primitives is not allowed.",
    "problem_description": "Using delay statements with primitives is not allowed.",
    "root_cause": "Using incorrect syntax or statements in the module definition, especially adding delay statements when using primitives.",
    "solution_pattern": "Remove the delay operator `#` in the definition when instantiating primitives.",
    "code_before": "module example(input d,rst, output s);\n   and (s, d, rst); #1\nendmodule",
    "code_after": "module example(input d,rst, output s);\n   and (s, d, rst);\nendmodule",
    "design_context": ["compilation", "primitive instantiation"],
    "common_modules": ["logic gates"],
    "severity": "major",
    "frequency": "common",
    "keywords": ["verilog", "compilation error", "module item", "invalid", "#"]
  }
]